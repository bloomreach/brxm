<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2007 Hippo

  Licensed under the Apache License, Version 2.0 (the  "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS"
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
  <properties>
    <title>Frontend Plugin Architecture</title>
  </properties>
  <head>
  </head>
  <body>
    <section name="Frontend Plugin Architecture">

      <p>
        Hippo ECM provides a plugin architecture to facilitate a customizable
        GUI.  The visual rendering is based on <a
        href="http://wicket.apache.org">Apache Wicket</a>.  All standard GUI
        components are written as plugins. The Hippo CMS application offers a
        default configuration for these plugins.  Customizing Hippo CMS comes
        down to editing this configuration, extending it with extra plugins 
        from <a href="http://forge.hippo-ecm.org/">the forge</a> or writing
        your own.
      </p>

      <subsection name="Customization by configuration">

        <p>
          Frontend plugins can extend the Wicket component model.  Wicket HTML
          fragments can contain references to plugins that are not added
          explicitly in the Java code. Instead, these references are resolved
          by the configuration in the repository.
        </p>

        <p>
          Example: suppose we have an ordinary Wicket panel called RootPanel,
          which contains three child panels: a ListPanel, a TreePanel and a
          SimplePanel. The child panels would need to be added explicitly in
          code, for example in the constructor or RootPanel:
        </p>
<source>
class RootPanel extends Panel {

  public RootPanel {
    add("list", new ListPanel());
    add("tree", new TreePanel());
    add("custom", new SimplePanel());
  }

}
</source>
        <p>
          This means that replacing SimplePanel with e.g. AdvancedPanel implies
          recompilation of the code.  The Wicket component hierarchy is fixed
          in the code.  Frontend plugins however need not be added explicitly
          in code, so if we make our RootPanel a RootPlugin, the wiring of the
          component hierarchy is postponed to runtime:
        </p>
<source>
class RootPlugin extends RenderPlugin {

  public RootPlugin(IPluginContext context, IPluginConfig config) {
    super(context, config);

    addExtensionPoint("list");
    addExtensionPoint("tree");
    addExtensionPoint("custom");
  }

}
</source>
        <p>
          The child plugins are added instead through (pseudo-) configuration:
        </p>
        <ul>
          <li>
            root:
            <ul>
              <li>class: org.example.RootPlugin</li>
              <li>id: service.root</li>
              <li>extensions = {
                    list: services.list,
                    tree: services.tree,
                    custom: services.custom
                  }</li>
            </ul>
          </li>
          <li>
            list:
            <ul>
              <li>class: org.example.ListPlugin</li>
              <li>id: services.list</li>
            </ul>
          </li>
          <li>
            tree:
            <ul>
              <li>class: org.example.TreePlugin</li>
              <li>id: services.tree</li>
            </ul>
          </li>
          <li>
            custom:
            <ul>
              <li>class: org.example.SimplePlugin</li>
              <li>id: services.custom</li>
            </ul>
          </li>
        </ul>
        <p>
          Changing the SimplePlugin to an AdvancedPlugin now only involves
          changing the configuration.  No recompilation is needed.
        </p>
        <p>
          This configuration is stored in the repository in nodes of (primary)
          type <b>frontend:plugin</b>.  The property <b>plugin.class</b>
          determines what Java class is instantiated.
        </p>
      </subsection>

      <subsection name="Applications">
        <p>
          Web applications that are completely configured from the repository
          consist of one page, "Home".  Applications consist of a configured
          collection of plugins, a <em>plugin cluster</em>.  The configuration
          is stored in the repository under
          <b>/hippo:configuration/hippo:frontend</b>.  The example below shows
          two application configurations ("foo" and "bar").
        </p>
<source>
[repository root]
`-- hippo:configuration
    `-- hippo:frontend
        |-- foo [frontend:plugincluster]
        `-- bar [frontend:plugincluster]
</source>
        <p>
          Each application has a plugin that registers an IRenderService under
          the name "service.root".  The Home page in each application adds the
          service's Wicket component (see IRenderService.getComponent()) to
          itself when this service registers.  The plugin must implement
          IRenderService, a feat most easily accomplished by extending the
          RenderPlugin class.  This plugin registers itself as the service, and
          also provides itself as the Wicket component to wire into the
          hierarchy.
        </p>
<source>
public class RootPlugin extends RenderPlugin {

    public RootPlugin(IPluginContext context, IPluginConfig config) {
        super(context, config);

        addExtensionPoint("extension");
    }

}
</source>
        <p>
          When the plugin is instantiated, it registers itself as the
          "service.root" render service (when configured correctly).  It
          listens for other (render) services that register under the service
          name that "extension" is an alias for.  When such a service
          registers, it is added to the component hierarchy.  If no such
          service exists, an empty panel is shown.
        </p>
        <p>
          The plugins that are configured in the repository node structure must therefore
          correspond to missing Wicket components in the HTML for RootPlugin.  For example,
          if the above root component has this html:
        </p>
<source>
&lt;html xmlns:wicket="http://wicket.apache.org/"&gt;
    &lt;wicket:panel&gt;
      &lt;p&gt;
        &lt;div wicket:id="extension">[sub plugin will be rendered here]&lt;/div&gt;
      &lt;/p&gt;
    &lt;/wicket:panel&gt;
&lt;/html>
</source>
        <p>
          then the repository structure that will generate the correct
          component hierarchy is:
        </p>
<source>
[repository root]
`-- configuration
    `-- frontend
        `-- application [frontend:plugincluster]
            |-- RootPlugin [frontend:plugin]
            |   + plugin.class : org.example.RootPlugin
            |   + wicket.id : service.root
            |   + extension : service.extension
            `-- subPlugin [frontend:plugin]
                + plugin.class : org.example.subPlugin
                + wicket.id : service.extension
</source>
        <p>
          Both frontend:plugin nodes, RootPlugin and subPlugin, need to have a
          property <b>plugin.class</b>, which contains the full class name of
          the plugin.  
        </p>
      </subsection>

      <subsection name="Plugin Configuration">
        <p>
          Each plugin has its own configuration that provides an indirection
          layer, used to translate plugin specific names 
          into application/cluster-wide names.  So when a plugin wants to
          know under what name it can find the model service, it looks up the
          value for the "wicket.model" key.  This value might be something like
          "perspective.browse.model", "935313c9-7fcb-42e8-9465-6080eb24693b" or
          "$#%345.*".  What matters here is that the plugin that provides the
          service registers it under the same name.
        </p>
      </subsection>

      <subsection name="Plugin Context">
        <p>
          As can be seen from the constructor signature, a plugin receives a
          plugin context when it is instantiated.  This context can be used to
          interact with the framework.  The following things can be achieved
          in this way:
        </p>
        <dl>
          <dt>Start a new cluster</dt>
          <dd>
            New plugins can be started by providing a cluster configuration.  The
            cluster is under the control of the plugin that started it.  When the
            original plugin is stopped, for example, the cluster will be stopped
            as well.
          </dd>
          <dt>Retrieve/register/unregister a service</dt>
          <dd>
            Any object that implements IClusterable can be registered as a
            service.  It will receive a unique service ID that can be used to
          register "decorator" interfaces, construct a naming scope or to 
            retrieve the service when the plugin context is not available.
          </dd>
          <dt>Register/unregister a service tracker</dt>
          <dd>
            It is possible to be notified when a service is registered under a
            particular name by registering a service tracker.  This is useful
            when services may come and go in an unpredictable manner and should
            be used whenever references to services are stored outside of the
            stack.
          </dd>
        </dl>
        <p>
          Because this is a fairly abstract model, it is recommended to use
          base classes that handle the interaction with the framework.
        </p>
        <p>
          The plugin context is private to the plugin.  I.e. a plugin can use
          it, but should not hand out references to other plugins.  The context
          handles the lifecycle of services and trackers.  When a plugin is
          stopped these are unregistered so there is no need for plugins to 
          do this.
        </p>
      </subsection>

      <subsection name="Dynamic Services">
        <p>
          It is sometimes desirable to dynamically instantiate plugins to
          extend the application in response to a user action.  For example,
          the workflow plugin starts and stops clusters of plugins that show
          lists of available actions for a document.
        </p>
        <p>
          Because the starting and stopping of a consumed service is under
          the control of a different plugin, in general no assumptions can
          be made about its availability.  There are three safe ways of 
          consuming services:
        </p>
        <ul>
          <li>
            Use IPluginContext.getService(name, clazz) to get the service
            whenever it is needed.  No references should be stored in
            objects.
          </li>
          <li>
            Register a service tracker if storing references is necessary.
            When the tracker is notified of a service's disappearance, the
            reference should be discarded.
          </li>
          <li>
            Store an IServiceReference and use it to get to the service
            whenever it is needed.  This is necessary in dialogs, where the
            plugin context is not directly available.  One can of course
            store an IServiceReference to the plugin if it is registered as
            a service itself, as in the case of RenderPlugin subclasses.
          </li>
        </ul>
      </subsection>

    </section>
  </body>
</document>
