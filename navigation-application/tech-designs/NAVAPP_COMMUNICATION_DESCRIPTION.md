# Introduction

## Feature Context

This document describes the navigation communication library that will be used in the Unified UI project for communication between the navigation application (“nav-app”) and brXM, brSM and 3rd party applications loaded in iframes in the navigation application window.

## Related Documentation

There is a list of relevant related documentation on [Confluence](https://docs.bloomreach.com/display/GE/Unified+Navigation).

## Relevance / Alignment with Company Strategy

Unified Navigation is part of the _Unified UI/UX_ initiative, which has the purpose of showing the potential of combining the brXM and brSM products in the BRX.

# Description

This library wraps [Penpal](https://github.com/Aaronius/penpal), a cross-origin window communication library that is based on the window.postMessage API. It defines the API applications loaded in iframes can use to talk to the nav-app in the parent window.

## Cross-window communication

In order for applications inside the iframes to communicate with the nav-app, we need to define a “cross window communication API”, which defines what messages, instructions or events an application can send to nav-app, or receive from it. Each application must load and use this library in order to be able to communicate with nav-app. Cross-window communication requires an API on both sides. The navigation communication library provides these APIs for the parent window to the applications inside the iframes for the nav-app and for the applications inside the iframe to communicate with nav-app. This is achieved through wrapping Penpal and using its cross window communication methods.

## Authorization bootstrapping of client apps

For client apps to function properly they require (security related) cookies on their domain. So before the navapp loads the client app sources in iframes it will pre-fetch those cookies. The login urls are specified in the appSettings.loginResources. When such a url is loaded in an iframe it should contain the cookie and use the communication library to connect to the parent (which is the navapp). The parentOrigin for connecting can be retrieved from the id_token provided by Auth0. The navapp connects to the login child apps (connectToChild will take care of creating an iframe) and waits until all login child apps have connected. If one or more of the login app promises rejects (or time out) then the navapp will logout and redirect to the login page. If all promises resolve then the navapp will continue loading the navigation configurations.

## Establishing the Communication Channel

In order to establish a communication channel between nav-app and the application running inside an iframe, the application must load the navigation communication library and register itself with the nav-app following the API.
It can then provide a specific set of methods to the nav-app for it to call. The parent will provide a similar set of methods to the application running in the iframe.

Example code from a child perspective:

```
BRNavigationCommunication.connectToParent({
  parentOrigin: '<whitelist the origin to match the authenticated origin>',
  methods: {
    navigate(path) {
      routeToPath(path);
    },
    beforeNavigate() {
      return outstandingWorkToBeDone();
    }
  }
})
.then((navApp) => {
   // Call a nav-app's method
   navApp.updateNavLocation(location);

   // Access nav-app properties
   var username = navApp.user.name;
 });
```

Once the application has retrieved the `navApp` object, it can use that to communicate with nav-app.

## Different ways of consuming the library in applications

The navigation communication library build will produce several artifacts that can be consumed by applications:

- EcmaScript Module to `import` into a javascript/typescript ESM application
- Typescript Interfaces to `import` into a typescript application for intellisense
- Normal EcmaScript 5 script file containing the library and bundled dependencies
- Optimized EcmaScript 5 script file containing the library and bundled dependencies

## API Definition

The latest released api definition can be found [here](https://javadoc.onehippo.org/14.0-preview/navapp/), (nightly on Jenkins [here](https://ci-xm.corp.bloomreach.com/view/All/job/cms_bloomreach-navigation-application/job/release%252F1.x.x/lastSuccessfulBuild/artifact/docs/index.html)). This api documentation will be the documentation generated by the last build of the navapp communication library.

## Async call handling

Because of current brXM behaviour the only option we have is to ignore subsequent menu clicks until a navigation has completed by either resolving or rejecting the navigation promise.

Site selection dropdown: disable dropdown until the site selection promises are done.

In general it makes sense for an action to be disabled until the previous action of that type has been resolved or rejected. It is not ideal, which would be responding graciously to new user input, but it is a simple solution.

## Error handling

The communication library can transfer errors from client applications to the nav-app. To facilitate that **onError** method has been added to the parent API. So if a client application detects any of these errors:

1. session timeout / not properly authenticated / not authorized;
2. unable to handle the path provided via **navigate** method;

it calls onError method and provides error code and optional error message which can be ignored by the nav-app.

Handling rejected promises when calling a provided parent or child api method is assumed to be done by the implementer of the method. The rejected promise usually tells that something went wrong with the connection. That could be the responsibility of the communication library like handling a timeout and retry of a call.

## Versioning

Where possible, the Navigation Communication library implements “graceful degradation” in case of version mismatches between nav-app and the application. However in some cases the applications in iframes might have to hide or disable certain UI or functionality if the nav-app that tries to load that application inside the iframe can not support it.

## User session management

Currently there is a method both in the parent and child api `onUserActivity`. Assuming all iframe apps have some way to detect user activity to prevent active logout this can be used to listen to and communicate to other apps the activity of the user.

When an application detects activity it should communicate this to the navapp which in turn will communicate it to the other apps to prevent them from logging out due to inactivity.

## Preventing Cross Site Scripting issues

Postmessage events contain a data object. This opens the risk of XSS attacks (see [Hunting postMessage Vulnerabilities](https://www.sec-1.com/blog/wp-content/uploads/2016/08/Hunting-postMessage-Vulnerabilities.pdf)). Therefore, the data must always be sanitized before it is being used. We can write our own code or find a library that we can use. To start, we should carefully read [Cross Site Scripting Prevention Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md) maintained by OWASP.

