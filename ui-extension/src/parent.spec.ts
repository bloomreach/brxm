/*
 * Copyright 2018-2019 Hippo B.V. (http://www.onehippo.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Disable TSLint for imports that start with an uppercase letter
 * @see https://github.com/Microsoft/tslint-microsoft-contrib/issues/387
 */
import Emittery = require('emittery'); // tslint:disable-line:import-name
import Penpal from 'penpal';           // tslint:disable-line:import-name
import { connect, Parent, ParentConnection } from './parent';

jest.mock('penpal');

// save globals that may be replaced in tests
const connectToParent = Penpal.connectToParent;

// reset mocked globals after each test
afterEach(() => {
  Penpal.connectToParent = connectToParent;
  (Penpal.connectToParent as jest.Mock).mockClear();
});

describe('connect', () => {
  let parentOrigin: string;
  let eventEmitter: Emittery;

  beforeEach(() => {
    parentOrigin = 'http://cms.example.com:8080';
    eventEmitter = new Emittery();
  });

  it('connects to the parent API', async () => {
    await connect(parentOrigin, eventEmitter);

    expect(Penpal.connectToParent).toHaveBeenCalled();
  });

  it('uses the provided parent origin', async () => {
    await connect(parentOrigin, eventEmitter);

    expect(Penpal.connectToParent).toHaveBeenCalledWith({
      parentOrigin,
      methods: expect.any(Object),
    });
  });

  describe('on success', () => {
    let parentConnection: ParentConnection;
    let parent: Parent;

    beforeEach(() => connect(parentOrigin, eventEmitter).then(pc => (parentConnection = pc)));
    beforeEach(async () => {
      const penpalConnection = (Penpal.connectToParent as jest.Mock).mock.results[0].value;
      parent = await penpalConnection.promise;
    });

    describe('parent connection', () => {
      describe('call', () => {
        it('calls a parent method', async () => {
          const refreshChannel = jest.spyOn(parent, 'refreshChannel');
          await parentConnection.call('refreshChannel', 'something');

          expect(refreshChannel).toHaveBeenCalledWith('something');
        });

        it('resolves with the data returned by the parent method', async () => {
          const page = await parentConnection.call('getPage') as any;

          expect(page.channel.contextPath).toBe('/site');
          expect(page.channel.id).toBe('testChannelId');
          expect(page.channel.mountPath).toBe('/sub-mount');
          expect(page.id).toBe('testPageId');
          expect(page.sitemapItem.id).toBe('testSitemapItemId');
          expect(page.path).toBe('/news/mypage.html');
          expect(page.url).toBe('http://www.example.com/site/sub-mount/news/mypage.html');
        });

        it('rejects with error code "IncompatibleParent" when the parent method does not exist', () => {
          // @ts-ignore: noSuchMethod is not assignable
          return expect(parentConnection.call('noSuchMethod')).rejects
            .toMatchObject({
              code: 'IncompatibleParent',
              message: 'missing noSuchMethod()',
            });
        });

        it('rejects with error code "InternalError" when the parent method throws an error', () => {
          // @ts-ignore: noSuchMethod is not assignable
          jest.spyOn(parent, 'refreshChannel').mockImplementation(() => {
            throw new Error('boo');
          });

          return expect(parentConnection.call('refreshChannel')).rejects
            .toMatchObject({
              code: 'InternalError',
              message: 'boo',
            });
        });

        it('rejects with error code "ConnectionDestroyed" when the parent connection is destroyed', () => {
          // as generated by penpal
          const error = new Error('Unable to send refreshChannel() call due to destroyed connection');

          jest.spyOn(parent, 'refreshChannel').mockImplementation(() => {
            throw Object.assign(error, { code: Penpal.ERR_CONNECTION_DESTROYED });
          });

          expect(parentConnection.call('refreshChannel')).rejects.toMatchObject(error);
        });

        it('rejects with error code "DialogExists" when the parent throws the same error', () => {
          // @ts-ignore: noSuchMethod is not assignable
          jest.spyOn(parent, 'openDialog').mockImplementation(() => {
            throw { code: 'DialogExists', message: 'test message' };
          });

          return expect(parentConnection.call('openDialog')).rejects
            .toMatchObject({
              code: 'DialogExists',
              message: 'test message',
            });
        });

        it('rejects with error code "DialogCanceled" when the parent throws the same error', () => {
          // @ts-ignore: noSuchMethod is not assignable
          jest.spyOn(parent, 'openDialog').mockImplementation(() => {
            throw { code: 'DialogCanceled', message: 'test message' };
          });

          return expect(parentConnection.call('openDialog')).rejects
            .toMatchObject({
              code: 'DialogCanceled',
              message: 'test message',
            });
        });
      });
    });

    describe('event emitter', () => {
      it('emits events emitted by the parent', async () => {
        const emitEvent = Penpal.connectToParent['mock'].calls[0][0].methods.emitEvent;
        const eventData = {};
        const listener = jest.fn();

        eventEmitter.on('event', listener);
        await emitEvent('event', eventData);

        expect(listener).toHaveBeenCalledWith(eventData);
      });
    });
  });

  describe('on failure', () => {
    it('rejects with error code "NotInIframe" when there is no parent', () => {
      const error = new Error('connectToParent() must be called within an iframe');

      Penpal.connectToParent = () => {
        // as generated by penpal
        throw Object.assign(error, { code: Penpal.ERR_NOT_IN_IFRAME });
      };

      return expect(connect(parentOrigin, eventEmitter)).rejects.toMatchObject(error);
    });
  });
});
